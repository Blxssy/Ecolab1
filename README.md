# Сортировка пузырьком

## Общая постановка задачи

Необходимо создать/модифицировать компонент EcoLab1, реализующий интерфейс с методом сортировки массива целых чисел пузырьком по возрастанию. Метод вызывается из тестовой программы, которая генерирует данные, выполняет сортировку и формирует сводную таблицу с результатами и сравнение со стандартной библиотечной функцией qsort.

## Реализуемый алгоритм сортировки пузырьком

Используется классический алгоритм с оптимизацией раннего выхода, когда во время итерации не произошло ни одной перестановки — массив считается отсортированным.

Основные шаги алгоритма:

1. Повторять проходы по массиву слева направо.
2. На каждом проходе сравнивать соседние элементы a[j] и a[j+1]; если a[j] > a[j+1], менять их местами.
3. После каждого полного прохода «всплывает» максимальный элемент; диапазон следующего прохода сокращается на 1.
4. Если за проход не было обменов, сортировка завершается.

## Асимптотика

* Временная сложность:
  * худший и средний случай: O(n²)
  * лучший случай: O(n)
* Сложность по памяти: O(1)

## Реализация

```c++
    if (me == 0 || pArray == 0) return ERR_ECO_POINTER;
    if (length < 2) return ERR_ECO_SUCCESES;

    for (i = 0; i + 1 < length; ++i) {
        swapped = 0;
        for (j = 0; j + 1 < (length - i); ++j) {
            if (pArray[j] > pArray[j + 1]) {
                int32_t t = pArray[j];
                pArray[j] = pArray[j + 1];
                pArray[j + 1] = t;
                swapped = 1;
            }
        }
        if (swapped == 0) break; /* ранний выход */
    }
    return ERR_ECO_SUCCESES;
```

## Пример работы

Тестовая программа генерирует случайный массив, дублирует его, затем:

* вызывает MyFunction над первой копией;
* вызывает qsort над второй копией;
* проверяет корректность (массив неубывающий);
* измеряет время обеих сортировок и печатает таблицу.

Измерения проводятся функцией clock() из стандартной библиотеки time.h и выводятся в миллисекундах.

## Сравнение с qsort (stdlib)

Ниже приведены результаты одного прогона для разных размеров массивов:
```md
Array Size   | COM (ms)   | qsort (ms)
-------------+------------+------------
64           | 0.000      | 0.000      
128          | 0.000      | 0.000      
256          | 0.000      | 1.000      
512          | 0.000      | 0.000      
1024         | 1.000      | 0.000      
2048         | 4.000      | 0.000      
4096         | 12.000     | 0.000      
8192         | 54.000     | 2.000     
16384        | 199.000    | 3.000      
32768        | 803.000    | 7.000      
65536        | 3275.000   | 17.000  
```


Интерпретация:
* Начиная с n ≈ 1024, пузырёк становится заметно медленнее qsort, что соответствует теоретическим оценкам: O(n²) против O(n log n).
* Оптимизация раннего выхода помогает только для почти отсортированных данных; на случайных данных выигрыш минимален.

## Время измерения

Время фиксируется как:

`ms = (double)(end - begin) / CLOCKS_PER_SEC * 1000.0`

где begin и end — значения clock() до и после вызова сортировки.

## Выводы

1. Реализация пузырьковой сортировки в EcoLab1 корректно упорядочивает массив по возрастанию и соответствует заявленной сигнатуре интерфейса.
2. Эксперимент подтверждает теорию: при росте размера массива время пузырьковой сортировки увеличивается квадратично и быстро уступает qsort.
3. Для учебных целей пузырёк удобен простотой, однако для практики предпочтительны алгоритмы O(n log n) (как минимум qsort), особенно на массивах от тысячи элементов и выше.
